"""
agent.py ‚Äì G≈Ç√≥wna logika agenta JADZIA

NAPRAWIONE:
- Obs≈Çuga stanu (state deadlock)
- Obs≈Çuga komend informacyjnych (listowanie plik√≥w)
- Poprawna interpretacja odpowiedzi u≈ºytkownika
- POZIOM 2: Model Selection (Haiku dla prostych zada≈Ñ)
"""

import os
import json
import asyncio
from typing import Optional, Tuple, Dict, List
from dotenv import load_dotenv

load_dotenv()

from .prompt import (
    get_system_prompt,
    get_planner_prompt,
    get_coder_prompt,
    get_approval_prompt,
    get_error_recovery_prompt,
    get_simple_response_prompt,
    get_task_complexity_prompt  # NOWE!
)
from .tools import (
    list_files, read_file, write_file,
    deploy, health_check, rollback,
    test_ssh_connection,
    list_directory, exec_ssh_command, get_path_type
)
from .diff import generate_diff, format_diff_for_display, create_change_summary
from .guardrails import validate_operation, OperationType
from .state import (
    agent_lock, LockError,
    load_state, save_state, clear_state,
    create_operation, update_operation_status,
    has_pending_operation, get_pending_operation_summary,
    OperationStatus, set_awaiting_response,
    store_diffs, get_stored_diffs,
    store_new_contents, get_stored_contents,
    get_operation_id, add_error
)
from .log import log_event, log_error, EventType
from .context import get_minimal_context
from .helpers import clean_code_for_file

# ============================================================
# KONFIGURACJA
# ============================================================

ANTHROPIC_API_KEY = os.getenv("ANTHROPIC_API_KEY", "")

# POZIOM 2: Dwa modele
MODEL_SONNET = "claude-sonnet-4-20250514"  # Z≈Ço≈ºone zadania
MODEL_HAIKU = "claude-haiku-4-5-20251001"     # Proste zadania (80% taniej!)

MAX_TOKENS = 4096
TIMEOUT = 120

# OPTYMALIZACJA POZIOM 1
MAX_FILE_SIZE = 10000
ENABLE_PROMPT_CACHING = True
TOKEN_STATS = {"input": 0, "output": 0, "cached": 0, "cost": 0.0}


# ============================================================
# CLAUDE API CLIENT
# ============================================================

def get_claude_client():
    """Tworzy klienta Anthropic"""
    if not ANTHROPIC_API_KEY:
        raise ValueError("Brak ANTHROPIC_API_KEY w .env")

    from anthropic import Anthropic
    return Anthropic(api_key=ANTHROPIC_API_KEY)


# ============================================================
# POZIOM 2: KLASYFIKACJA ZADA≈É
# ============================================================

async def classify_task_complexity(user_input: str, plan: Dict) -> str:
    """
    Klasyfikuje zadanie jako 'simple' lub 'complex'.
    
    PROSTE zadania (Haiku):
    - Dodanie komentarzy
    - Zmiana kolor√≥w/styl√≥w CSS
    - Zmiana tekst√≥w
    - Proste modyfikacje HTML
    
    Z≈ÅO≈ªONE zadania (Sonnet):
    - Nowe funkcje PHP
    - Logika biznesowa
    - Integracje z WooCommerce
    - Z≈Ço≈ºone zmiany w wielu plikach
    
    Returns:
        "simple" lub "complex"
    """
    # Szybka heurystyka (bez dodatkowego wywo≈Çania API)
    simple_keywords = [
        "komentarz", "comment", "kolor", "color", "tekst", "text",
        "zmie≈Ñ", "change", "dodaj", "add", "usu≈Ñ", "remove",
        "css", "style", "wyglƒÖd"
    ]
    
    complex_keywords = [
        "funkcj", "function", "hook", "action", "filter",
        "woocommerce", "payment", "p≈Çatno≈õƒá", "checkout",
        "logik", "logic", "walidacj", "validation"
    ]
    
    user_lower = user_input.lower()
    plan_str = json.dumps(plan).lower()
    
    # Sprawd≈∫ liczbƒô plik√≥w do modyfikacji
    files_count = len(plan.get("files_to_modify", []))
    
    # Z≈Ço≈ºone je≈õli wiele plik√≥w
    if files_count > 2:
        return "complex"
    
    # Sprawd≈∫ s≈Çowa kluczowe
    simple_score = sum(1 for kw in simple_keywords if kw in user_lower or kw in plan_str)
    complex_score = sum(1 for kw in complex_keywords if kw in user_lower or kw in plan_str)
    
    if complex_score > 0:
        return "complex"
    
    if simple_score > 0:
        return "simple"
    
    # Domy≈õlnie z≈Ço≈ºone (bezpieczniej)
    return "complex"


# ============================================================
# FUNKCJA call_claude Z POZIOM 2
# ============================================================

async def call_claude(
    messages: List[Dict],
    system: Optional[str] = None,
    timeout: int = TIMEOUT,
    use_caching: bool = True,
    task_complexity: str = "complex"  # NOWE!
) -> str:
    """
    Wywo≈Çuje Claude API z optymalizacjami POZIOM 1 + 2.
    
    POZIOM 1: Prompt caching
    POZIOM 2: Model selection based on task complexity
    """
    try:
        client = get_claude_client()
        loop = asyncio.get_event_loop()
        
        # POZIOM 2: Wyb√≥r modelu
        if task_complexity == "simple":
            model = MODEL_HAIKU
            print(f"[MODEL] Zadanie: simple ‚Üí Haiku (80% taniej!)")
        else:
            model = MODEL_SONNET
            print(f"[MODEL] Zadanie: complex ‚Üí Sonnet")

        def _call():
            system_content = system or get_system_prompt()

            if ENABLE_PROMPT_CACHING and use_caching:
                system_param = [{
                    "type": "text",
                    "text": system_content,
                    "cache_control": {"type": "ephemeral"}
                }]
            else:
                system_param = system_content

            response = client.messages.create(
                model=model,  # POZIOM 2: Dynamiczny wyb√≥r modelu
                max_tokens=MAX_TOKENS,
                system=system_param,
                messages=messages
            )

            # MONITORING
            usage = response.usage
            TOKEN_STATS["input"] += usage.input_tokens
            TOKEN_STATS["output"] += usage.output_tokens

            if hasattr(usage, 'cache_read_input_tokens'):
                TOKEN_STATS["cached"] += usage.cache_read_input_tokens

            # Koszt zale≈ºy od modelu
            if model == MODEL_HAIKU:
                # Haiku: $0.30/M input, $1.50/M output, $0.03/M cached
                input_cost = (usage.input_tokens / 1_000_000) * 0.30
                output_cost = (usage.output_tokens / 1_000_000) * 1.50
                cached_cost = 0
                if hasattr(usage, 'cache_read_input_tokens'):
                    cached_cost = (usage.cache_read_input_tokens / 1_000_000) * 0.03
            else:
                # Sonnet: $3/M input, $15/M output, $0.30/M cached
                input_cost = (usage.input_tokens / 1_000_000) * 3.0
                output_cost = (usage.output_tokens / 1_000_000) * 15.0
                cached_cost = 0
                if hasattr(usage, 'cache_read_input_tokens'):
                    cached_cost = (usage.cache_read_input_tokens / 1_000_000) * 0.30

            call_cost = input_cost + output_cost + cached_cost
            TOKEN_STATS["cost"] += call_cost

            print(f"[COST] Wywo≈Çanie: ${call_cost:.4f} | "
                  f"Input: {usage.input_tokens} | "
                  f"Output: {usage.output_tokens} | "
                  f"Cached: {getattr(usage, 'cache_read_input_tokens', 0)}")

            return response.content[0].text

        result = await asyncio.wait_for(
            loop.run_in_executor(None, _call),
            timeout=timeout
        )

        return result

    except asyncio.TimeoutError:
        raise RuntimeError(f"Claude nie odpowiedzial w ciagu {timeout} sekund")
    except Exception as e:
        raise RuntimeError(f"Blad Claude API: {e}")


def get_cost_stats() -> dict:
    """Zwraca statystyki u≈ºycia i koszt√≥w."""
    return {
        "total_input_tokens": TOKEN_STATS["input"],
        "total_output_tokens": TOKEN_STATS["output"],
        "total_cached_tokens": TOKEN_STATS["cached"],
        "total_cost_usd": round(TOKEN_STATS["cost"], 4),
        "estimated_savings_from_cache": round(
            (TOKEN_STATS["cached"] / 1_000_000) * (3.0 - 0.30), 4
        ) if TOKEN_STATS["cached"] > 0 else 0
    }


def reset_cost_stats():
    """Resetuje statystyki (np. na poczƒÖtku dnia)."""
    TOKEN_STATS["input"] = 0
    TOKEN_STATS["output"] = 0
    TOKEN_STATS["cached"] = 0
    TOKEN_STATS["cost"] = 0.0


# ============================================================
# G≈Å√ìWNA FUNKCJA PROCESS_MESSAGE
# ============================================================

async def process_message(
    user_input: str,
    chat_id: str
) -> Tuple[str, bool, Optional[str]]:
    """G≈Ç√≥wna funkcja przetwarzajƒÖca wiadomo≈õƒá u≈ºytkownika."""

    try:
        try:
            with agent_lock(timeout=5):
                return await _process_message_internal(user_input, chat_id)
        except LockError:
            return (
                "Agent jest zajety inna operacja. Poczekaj chwile i sprobuj ponownie.",
                False,
                None
            )

    except Exception as e:
        log_error(str(e))
        return await handle_error(e, chat_id)


async def _process_message_internal(
    user_input: str,
    chat_id: str
) -> Tuple[str, bool, Optional[str]]:
    """Wewnƒôtrzna logika przetwarzania"""

    lower_input = user_input.strip().lower()

    # Sprawd≈∫ specjalne komendy
    if lower_input in ["/status", "status"]:
        return await handle_status_command()

    if lower_input in ["/rollback", "rollback", "cofnij"]:
        return await handle_rollback_command()

    if lower_input in ["/clear", "clear", "anuluj"]:
        return await handle_clear_command()

    if lower_input in ["/help", "help", "pomoc"]:
        return handle_help_command()

    if lower_input in ["/test", "test"]:
        return await handle_test_command()

    # Sprawd≈∫ czy to odpowied≈∫ T/N
    if lower_input in ["t", "tak", "yes", "y", "ok", "dawaj", "+", "potwierdz"]:
        state = load_state()
        if state and state.get("awaiting_response"):
            return await handle_approval(state, True)
        else:
            return ("Nie ma zadnej operacji do potwierdzenia.", False, None)

    if lower_input in ["n", "nie", "no", "stop", "anuluj", "-", "cancel"]:
        state = load_state()
        if state and state.get("awaiting_response"):
            return await handle_approval(state, False)
        else:
            return ("Nie ma zadnej operacji do anulowania.", False, None)

    # Sprawd≈∫ czy czekamy na odpowied≈∫
    state = load_state()
    if state and state.get("awaiting_response"):
        return await handle_user_response(user_input, state, chat_id)

    # Sprawd≈∫ czy jest niezako≈Ñczona operacja
    if has_pending_operation():
        state = load_state()
        if state:
            if state.get("status") == OperationStatus.DIFF_READY:
                diffs = get_stored_diffs()
                if diffs:
                    summary = create_change_summary(diffs)
                    set_awaiting_response(True, "approval")
                    return (
                        f"Masz oczekujace zmiany:\n\n{summary}\n\n**Potwierdzasz? [T/N]**",
                        True,
                        "approval"
                    )

        summary = get_pending_operation_summary()
        return (
            f"{summary}\n\nWpisz T aby kontynuowac lub N aby anulowac.",
            True,
            "continue_operation"
        )

    # Nowa operacja
    return await handle_new_operation(user_input, chat_id)


# ============================================================
# OBS≈ÅUGA ZATWIERDZENIA
# ============================================================

async def handle_approval(state: Dict, approved: bool) -> Tuple[str, bool, Optional[str]]:
    """Obs≈Çuguje zatwierdzenie lub odrzucenie zmian"""

    awaiting_type = state.get("awaiting_type", "")
    operation_id = state.get("id")

    if not approved:
        clear_state()
        log_event(EventType.USER_REJECTED, "Uzytkownik odrzucil zmiany", operation_id=operation_id)
        return ("Zmiany odrzucone. Operacja anulowana.", False, None)

    # Zatwierdzono
    if awaiting_type == "approval":
        return await execute_approved_changes(state)

    elif awaiting_type == "deploy_approval":
        return await execute_deploy(state)

    elif awaiting_type == "continue_operation":
        return await resume_operation(state)

    else:
        if get_stored_contents():
            return await execute_approved_changes(state)
        else:
            clear_state()
            return ("Brak zmian do wykonania.", False, None)


# ============================================================
# OBS≈ÅUGA NOWEJ OPERACJI
# ============================================================

async def handle_new_operation(
    user_input: str,
    chat_id: str
) -> Tuple[str, bool, Optional[str]]:
    """Obs≈Çuguje nowe polecenie"""

    # Sprawd≈∫ czy to polecenie informacyjne
    info_keywords = ["wylistuj", "pokaz", "lista", "sprawdz", "ile", "jakie", "co jest", "ls", "dir"]
    is_info_request = any(kw in user_input.lower() for kw in info_keywords)

    if is_info_request:
        return await handle_info_request(user_input)

    # Utw√≥rz operacjƒô
    operation = create_operation(user_input)
    operation_id = operation["id"]

    log_event(
        EventType.OPERATION_START,
        f"Nowa operacja: {user_input[:100]}",
        operation_id=operation_id
    )

    try:
        # 1. PLANOWANIE
        update_operation_status(OperationStatus.PLANNING)

        try:
            project_files = list_files("*.php") + list_files("*.css")
            project_structure = "\n".join(project_files[:50])
        except Exception:
            project_structure = "Nie mozna pobrac struktury plikow"

        plan_prompt = get_planner_prompt(user_input, project_structure)
        plan_response = await call_claude([{"role": "user", "content": plan_prompt}])

        plan = parse_plan(plan_response)

        update_operation_status(
            OperationStatus.PLANNING,
            plan=plan,
            files_to_modify=plan.get("files_to_modify", [])
        )

        log_event(
            EventType.PLAN_CREATED,
            f"Plan utworzony: {len(plan.get('files_to_modify', []))} plikow",
            data=plan,
            operation_id=operation_id
        )

        # Je≈õli sƒÖ pytania od Claude
        if plan.get("questions") and len(plan.get("questions", [])) > 0:
            questions_text = "\n".join(f"- {q}" for q in plan["questions"])
            set_awaiting_response(True, "answer_questions")
            return (
                f"Mam pytania zanim zacznƒô:\n\n{questions_text}\n\nProszƒô o odpowied≈∫.",
                True,
                "answer_questions"
            )

        # Je≈õli brak plik√≥w do modyfikacji - prosta odpowied≈∫
        if not plan.get("files_to_modify") and not plan.get("files_to_read"):
            clear_state()
            simple_prompt = get_simple_response_prompt(user_input)
            response = await call_claude([{"role": "user", "content": simple_prompt}])
            return (response, False, None)

        # 2. CZYTANIE PLIK√ìW I GENEROWANIE ZMIAN
        return await read_and_generate_changes(plan, user_input, operation_id)

    except Exception as e:
        add_error(str(e))
        update_operation_status(OperationStatus.FAILED)
        raise


# ============================================================
# OBS≈ÅUGA ≈ªƒÑDA≈É INFORMACYJNYCH
# ============================================================

async def handle_info_request(user_input: str) -> Tuple[str, bool, Optional[str]]:
    """Obs≈Çuguje ≈ºƒÖdania informacyjne (listowanie plik√≥w itp.)"""

    lower_input = user_input.lower()

    path = ""

    path_indicators = ["w ", "z ", "folder ", "katalog ", "directory ", "path "]
    for indicator in path_indicators:
        if indicator in lower_input:
            idx = lower_input.find(indicator) + len(indicator)
            rest = user_input[idx:].strip()
            path = rest.split()[0] if rest else ""
            break

    if "child" in lower_input:
        path = "wp-content/themes/hello-theme-child-master"
    elif "theme" in lower_input or "motyw" in lower_input:
        path = "wp-content/themes"
    elif "plugin" in lower_input or "wtyczk" in lower_input:
        path = "wp-content/plugins"

    try:
        success, files, error = list_directory(path, recursive=False)

        if success:
            result = f"**Zawartosc katalogu: {path or '/'}**\n\n"
            result += "```\n"
            result += "\n".join(files[:50])
            if len(files) > 50:
                result += f"\n... i {len(files) - 50} wiecej"
            result += "\n```"
            return (result, False, None)
        else:
            return (f"Blad listowania: {error}", False, None)

    except Exception as e:
        return (f"Blad: {e}", False, None)


# ============================================================
# FUNKCJE DO SKRACANIA D≈ÅUGICH PLIK√ìW
# ============================================================

def truncate_file_content(content: str, max_size: int = MAX_FILE_SIZE) -> tuple[str, bool]:
    """Skraca zawarto≈õƒá pliku je≈õli jest za d≈Çuga."""
    if len(content) <= max_size:
        return content, False

    chunk_size = max_size // 2 - 100

    start = content[:chunk_size]
    end = content[-chunk_size:]

    skipped = len(content) - (chunk_size * 2)
    skipped_lines = content[chunk_size:-chunk_size].count('\n')

    truncated = (
        f"{start}\n\n"
        f"[... POMINIƒòTO {skipped} znak√≥w ({skipped_lines} linii) ...]\n\n"
        f"{end}"
    )

    return truncated, True


def smart_truncate_for_task(content: str, task: str, file_path: str) -> str:
    """Inteligentne skracanie - pr√≥buje znale≈∫ƒá relevantny fragment."""
    if len(content) <= MAX_FILE_SIZE:
        return content

    task_lower = task.lower()

    # Szukaj funkcji
    if "function" in task_lower or "funkcj" in task_lower:
        import re
        func_match = re.search(r'funkcj[ƒôa]\s+(\w+)|function\s+(\w+)', task, re.IGNORECASE)
        if func_match:
            func_name = func_match.group(1) or func_match.group(2)
            func_pos = content.find(f"function {func_name}")
            if func_pos == -1:
                func_pos = content.find(f"def {func_name}")

            if func_pos != -1:
                start = max(0, func_pos - 500)
                end = min(len(content), func_pos + MAX_FILE_SIZE - 500)
                return content[start:end]

    # Szukaj CSS selectora
    if file_path.endswith('.css') or file_path.endswith('.scss'):
        import re
        selector_match = re.search(r'\.([\w-]+)|\#([\w-]+)', task)
        if selector_match:
            selector = selector_match.group(0)
            selector_pos = content.find(selector)
            if selector_pos != -1:
                start = max(0, selector_pos - 500)
                end = min(len(content), selector_pos + MAX_FILE_SIZE - 500)
                return content[start:end]

    # Fallback
    truncated, _ = truncate_file_content(content, MAX_FILE_SIZE)
    return truncated


async def read_and_generate_changes(
    plan: Dict,
    user_input: str,
    operation_id: str
) -> Tuple[str, bool, Optional[str]]:
    """Czyta pliki i generuje zmiany"""

    update_operation_status(OperationStatus.FILES_READ)

    files_to_read = plan.get("files_to_read", []) + plan.get("files_to_modify", [])
    files_to_read = list(set(files_to_read))

    # Przeczytaj pliki
    file_contents = {}
    errors = []

    for path in files_to_read:
        try:
            path_type = get_path_type(path)

            if path_type == "directory":
                success, files, error = list_directory(path)
                if success:
                    file_contents[path] = f"[KATALOG] Zawarto≈õƒá:\n" + "\n".join(files[:20])
                else:
                    errors.append(f"{path}: {error}")
            elif path_type == "file":
                content = read_file(path)
                file_contents[path] = content
            else:
                errors.append(f"{path}: nie istnieje")

        except Exception as e:
            errors.append(f"{path}: {e}")

    if errors and not file_contents:
        clear_state()
        return (
            f"Nie udalo sie przeczytac plikow:\n" + "\n".join(errors),
            False, None
        )

    files_to_modify = [f for f in plan.get("files_to_modify", [])
                       if f in file_contents and not file_contents[f].startswith("[KATALOG]")]

    if not files_to_modify:
        clear_state()
        result = "**Wyniki analizy:**\n\n"
        for path, content in file_contents.items():
            if content.startswith("[KATALOG]"):
                result += f"üìÅ **{path}**\n{content}\n\n"
            else:
                result += f"üìÑ **{path}** ({len(content)} znakow)\n"

        if errors:
            result += "\n**Bledy:**\n" + "\n".join(errors)

        return (result, False, None)

    # POZIOM 2: Klasyfikuj z≈Ço≈ºono≈õƒá zadania
    task_complexity = await classify_task_complexity(user_input, plan)
    
    new_contents = {}
    diffs = {}

    for path in files_to_modify:
        old_content_full = file_contents[path]

        old_content = smart_truncate_for_task(
            old_content_full,
            task=plan.get('understood_intent', user_input),
            file_path=path
        )

        if len(old_content) < len(old_content_full):
            print(f"[OPTYM] Skr√≥cono plik {path}: "
                  f"{len(old_content_full)} ‚Üí {len(old_content)} znak√≥w "
                  f"(oszczƒôdno≈õƒá: {len(old_content_full) - len(old_content)})")

        coder_prompt = get_coder_prompt(
            file_path=path,
            current_content=old_content,
            task_description=f"{plan.get('understood_intent', user_input)}\n\nKroki: {plan.get('steps', [])}",
            conventions=get_minimal_context()
        )

        # POZIOM 2: U≈ºyj odpowiedniego modelu
        new_content = await call_claude(
            [{"role": "user", "content": coder_prompt}],
            task_complexity=task_complexity  # NOWE!
        )

        # Wyczy≈õƒá markdown
        new_content_cleaned = clean_code_for_file(new_content, path)
        new_contents[path] = new_content_cleaned

        diff = generate_diff(old_content, new_content_cleaned, path)
        diffs[path] = diff

    # Zapisz do stanu
    store_diffs(diffs)

    if not store_new_contents(new_contents):
        add_error("Nie udalo sie zapisac nowych zawartosci do stanu!")
        return (
            "Blad wewnetrzny: nie mozna zapisac zmian do stanu. Sprobuj ponownie.",
            False, None
        )

    update_operation_status(OperationStatus.DIFF_READY)

    log_event(
        EventType.DIFF_GENERATED,
        f"Wygenerowano diffy dla {len(diffs)} plikow",
        operation_id=operation_id
    )

    # Poka≈º u≈ºytkownikowi
    summary = create_change_summary(diffs)

    diff_preview = ""
    for path, diff in diffs.items():
        diff_preview += f"\n\n--- {path} ---\n"
        diff_preview += format_diff_for_display(diff, max_lines=30)

    set_awaiting_response(True, "approval")

    return (
        f"**PLAN:** {plan.get('understood_intent', 'Zmiany w plikach')}\n\n"
        f"{summary}\n"
        f"{diff_preview}\n\n"
        f"**Potwierdzasz zmiany? [T/N]**",
        True,
        "approval"
    )


# ============================================================
# OBS≈ÅUGA ODPOWIEDZI U≈ªYTKOWNIKA
# ============================================================

async def handle_user_response(
    user_input: str,
    state: Dict,
    chat_id: str
) -> Tuple[str, bool, Optional[str]]:
    """Obs≈Çuguje odpowied≈∫ u≈ºytkownika"""

    awaiting_type = state.get("awaiting_type", "")

    approval_prompt = get_approval_prompt(user_input)
    interpretation = await call_claude([{"role": "user", "content": approval_prompt}])
    interpretation = interpretation.strip().lower()

    if interpretation == "approve":
        return await handle_approval(state, True)

    elif interpretation == "reject":
        return await handle_approval(state, False)

    elif interpretation == "question":
        set_awaiting_response(True, awaiting_type)

        response = await call_claude([
            {"role": "user", "content": state.get("user_input", "")},
            {"role": "assistant", "content": "Przygotowalem zmiany..."},
            {"role": "user", "content": user_input}
        ])
        return (f"{response}\n\n**Potwierdzasz zmiany? [T/N]**", True, awaiting_type)

    else:
        set_awaiting_response(True, awaiting_type)
        return (
            "Nie zrozumialem. Wpisz **T** aby zatwierdzic lub **N** aby odrzucic.",
            True,
            awaiting_type
        )


# ============================================================
# WYKONANIE ZMIAN
# ============================================================

async def execute_approved_changes(state: Dict) -> Tuple[str, bool, Optional[str]]:
    """Zapisuje zatwierdzone zmiany"""

    operation_id = state.get("id")
    new_contents = get_stored_contents()

    if not new_contents:
        clear_state()
        return ("Brak zmian do zapisania.", False, None)

    log_event(EventType.USER_APPROVED, "Uzytkownik zatwierdzil zmiany", operation_id=operation_id)

    update_operation_status(OperationStatus.WRITING)

    written = []
    errors = []

    for path, content in new_contents.items():
        try:
            write_file(path, content, operation_id)
            written.append(path)
        except Exception as e:
            errors.append(f"{path}: {e}")
            add_error(f"Blad zapisu {path}: {e}")

    if errors and not written:
        update_operation_status(OperationStatus.FAILED)
        clear_state()
        return (
            f"Blad zapisu plikow:\n" + "\n".join(errors),
            False, None
        )

    update_operation_status(OperationStatus.WRITTEN, files_written=written)

    set_awaiting_response(True, "deploy_approval")

    msg = f"‚úÖ Zapisano {len(written)} plikow:\n"
    msg += "\n".join(f"- {f}" for f in written)

    if errors:
        msg += f"\n\n‚ö†Ô∏è Bledy:\n" + "\n".join(errors)

    msg += "\n\n**Wykonac deploy (sprawdzic czy strona dziala)? [T/N]**"

    return (msg, True, "deploy_approval")


async def execute_deploy(state: Dict) -> Tuple[str, bool, Optional[str]]:
    """Wykonuje deploy"""

    operation_id = state.get("id")
    update_operation_status(OperationStatus.DEPLOYING)

    result = deploy(operation_id)

    update_operation_status(OperationStatus.COMPLETED, deploy_result=result)
    clear_state()

    log_event(EventType.OPERATION_END, "Operacja zakonczona", operation_id=operation_id)

    if result["status"] == "ok":
        return (f"‚úÖ Deploy zakonczony!\n{result['msg']}", False, None)
    else:
        return (
            f"‚ö†Ô∏è Deploy z ostrzezeniem:\n{result['msg']}\n\nUzyj /rollback jesli cos nie dziala.",
            False, None
        )


async def resume_operation(state: Dict) -> Tuple[str, bool, Optional[str]]:
    """Wznawia przerwana operacjƒô"""

    status = state.get("status")

    if status == OperationStatus.DIFF_READY:
        diffs = get_stored_diffs()
        if diffs:
            summary = create_change_summary(diffs)
            set_awaiting_response(True, "approval")
            return (f"Kontynuuje...\n\n{summary}\n\n**Potwierdzasz? [T/N]**", True, "approval")

    if status == OperationStatus.WRITTEN:
        set_awaiting_response(True, "deploy_approval")
        return ("Pliki zapisane. **Wykonac deploy? [T/N]**", True, "deploy_approval")

    clear_state()
    return ("Nie mozna wznowic operacji. Zaczynam od nowa.", False, None)


# ============================================================
# KOMENDY SPECJALNE
# ============================================================

async def handle_status_command() -> Tuple[str, bool, Optional[str]]:
    """Obs≈Çuguje /status"""
    state = load_state()

    if not state:
        return ("‚úÖ Agent jest gotowy. Brak aktywnych operacji.", False, None)

    return (
        f"**STATUS AGENTA**\n\n"
        f"ID: {state.get('id', 'brak')}\n"
        f"Status: {state.get('status', 'nieznany')}\n"
        f"Polecenie: {state.get('user_input', 'brak')[:100]}\n"
        f"Pliki do zmiany: {len(state.get('files_to_modify', []))}\n"
        f"Pliki zapisane: {len(state.get('files_written', []))}\n"
        f"Oczekuje odpowiedzi: {state.get('awaiting_response', False)}\n"
        f"Typ odpowiedzi: {state.get('awaiting_type', 'brak')}",
        False, None
    )


async def handle_rollback_command() -> Tuple[str, bool, Optional[str]]:
    """Obs≈Çuguje /rollback"""
    result = rollback()
    clear_state()

    if result["status"] == "ok":
        return (f"‚úÖ Rollback zakonczony.\nPrzywrocono: {', '.join(result.get('restored', []))}", False, None)
    else:
        return (f"‚ö†Ô∏è Rollback: {result['msg']}", False, None)


async def handle_clear_command() -> Tuple[str, bool, Optional[str]]:
    """Obs≈Çuguje /clear"""
    clear_state()
    return ("‚úÖ Stan wyczyszczony. Agent gotowy do nowych polecen.", False, None)


def handle_help_command() -> Tuple[str, bool, Optional[str]]:
    """Obs≈Çuguje /help"""
    return (
        "**JADZIA - Pomoc**\n\n"
        "Jestem asystentem do zarzadzania sklepem internetowym.\n\n"
        "**Komendy:**\n"
        "/status - sprawdz status agenta\n"
        "/rollback - cofnij ostatnie zmiany\n"
        "/clear - wyczysc stan (awaryjne)\n"
        "/test - test polaczenia SSH\n"
        "/help - ta pomoc\n\n"
        "**Przyklady polecen:**\n"
        "- 'Zmien kolor przyciskow na niebieski'\n"
        "- 'Wylistuj pliki w motywie child'\n"
        "- 'Dodaj baner promocyjny na stronie glownej'\n"
        "- 'Popraw tekst w stopce'\n\n"
        "**Odpowiedzi:**\n"
        "- T / tak - zatwierdz zmiany\n"
        "- N / nie - odrzuc zmiany\n\n"
        "Zawsze pokazuje zmiany przed zapisaniem i czekam na Twoja zgode.",
        False, None
    )


async def handle_test_command() -> Tuple[str, bool, Optional[str]]:
    """Obs≈Çuguje /test"""
    success, msg = test_ssh_connection()
    if success:
        return (f"‚úÖ Test SSH: OK\n{msg}", False, None)
    else:
        return (f"‚ùå Test SSH: BLAD\n{msg}", False, None)


# ============================================================
# OBS≈ÅUGA B≈ÅƒòD√ìW
# ============================================================

async def handle_error(
    error: Exception,
    chat_id: str
) -> Tuple[str, bool, Optional[str]]:
    """Obs≈Çuguje b≈Çƒôdy"""

    error_msg = str(error)

    try:
        state = load_state()
        recovery_prompt = get_error_recovery_prompt(
            error_message=error_msg,
            context=f"Chat: {chat_id}",
            operation_state=state.get("status", "nieznany") if state else "brak operacji"
        )

        response = await call_claude([{"role": "user", "content": recovery_prompt}])
        return (response, False, None)

    except Exception:
        return (
            f"‚ùå Wystapil blad: {error_msg}\n\n"
            "Mozesz:\n"
            "- /rollback - cofnac zmiany\n"
            "- /clear - wyczysc stan\n"
            "- /status - sprawdz status",
            False, None
        )


# ============================================================
# HELPERS
# ============================================================

def parse_plan(response: str) -> Dict:
    """Parsuje odpowied≈∫ Claude z planem"""

    try:
        start = response.find('{')
        end = response.rfind('}') + 1

        if start != -1 and end > start:
            json_str = response[start:end]
            return json.loads(json_str)
    except json.JSONDecodeError:
        pass

    return {
        "understood_intent": response[:200] if response else "Nieznane",
        "files_to_read": [],
        "files_to_modify": [],
        "steps": [response[:500] if response else "Analiza"],
        "questions": [],
        "risks": []
    }
